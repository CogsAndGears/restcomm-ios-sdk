/*
 * This file is part of the Sofia-SIP package
 *
 * Copyright (C) 2006 Nokia Corporation.
 *
 * Contact: Kai Vehmanen <kai.vehmanen@nokia.com>
 *
 * * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 */

/*
 * Status:
 *  - nop
 *
 * Todo:
 *  - not yet working
 *  - udpsink does not support 'sockfd' but requires 
 *    dest:port to be added to the packets 'dynudpsink'
 *
 * Notes:
 *  - ...
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if HAVE_GST

// this is supposed to be generated by configure script, which doesn't apply for XCode (at least for now). Let's hard-code it
#define SOFSIP_DEFAULT_AUDIO "ALSA"

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#include <gst/gst.h>
#include <gio/gio.h>

#include "sdp_utils.h"
#include "ssc_media_gst.h"
//#include "ssc_media_gst_utils.h"
//#include "farsight-netsocket-stun.h"
//#include "farsight-netsocket-utils.h"

#if !HAVE_G_DEBUG
#include "replace_g_debug.h"
#endif

/* Signals */
enum {
    SIGNAL_LAST
};

/* props */
enum {
    PROP_LAST,
    PROP_AUDIO_INPUT_TYPE,
    PROP_AUDIO_INPUT_DEVICE,
    PROP_AUDIO_OUTPUT_TYPE,
    PROP_AUDIO_OUTPUT_DEVICE,
    PROP_STUN_SERVER,
    PROP_STUN_DOMAIN
};

static void ssc_media_gst_class_init    (SscMediaGstClass *klass);
static void ssc_media_gst_init          (SscMediaGst *sscm);
static void ssc_media_gst_dispose       (GObject *object);
static void ssc_media_gst_finalize      (GObject *object);

static void ssc_media_gst_set_property (GObject      *object,
                                        guint         prop_id,
                                        const GValue *value,
                                        GParamSpec   *pspec);
static void ssc_media_gst_get_property (GObject    *object,
                                        guint       prop_id,
                                        GValue     *value,
                                        GParamSpec *pspec);

static int priv_activate_gst(SscMedia *sscm);
static int priv_deactivate_gst(SscMedia *sscm);
static int priv_refresh_gst(SscMedia *sscm);
static int priv_static_capabilities_gst(SscMedia *sscm, char **dst);

static gboolean priv_cb_pipeline_bus (GstBus *bus, GstMessage *message, gpointer data);
//static void priv_cb_ready(FarsightNetsocket *netsocket, gpointer data);
//static int priv_update_rx_elements(SscMediaGst *self);
static int priv_update_tx_elements(SscMediaGst *self);
static int priv_setup_rtpelements(SscMediaGst *self);
static gboolean priv_verify_required_elements(void);

static GObjectClass *parent_class = NULL;
/* static guint ssc_media_gst_signals[SIGNAL_LAST] = { 0 }; */

GType
ssc_media_gst_get_type (void)
{
    static GType type = 0;
    
    if (type == 0) {
        static const GTypeInfo info = {
            sizeof (SscMediaGstClass),
            NULL,
            NULL,
            (GClassInitFunc) ssc_media_gst_class_init,
            NULL,
            NULL,
            sizeof (SscMediaGst),
            0,
            (GInstanceInitFunc) ssc_media_gst_init
        };
        
        if (priv_verify_required_elements()) {
            type = g_type_register_static (SSC_MEDIA_TYPE,
                                           "SscMediaGstType",
                                           &info, 0);
        }
    }
    
    return type;
}

static void ssc_media_gst_class_init (SscMediaGstClass *klass)
{
    GObjectClass *gobject_class;
    SscMediaClass *parent_class = SSC_MEDIA_CLASS(klass);
    
    g_debug("%s:%d", G_STRFUNC, __LINE__);
    
    gobject_class = (GObjectClass *) klass;
    gobject_class->dispose = ssc_media_gst_dispose;
    gobject_class->finalize = ssc_media_gst_finalize;
    gobject_class->set_property = ssc_media_gst_set_property;
    gobject_class->get_property = ssc_media_gst_get_property;
    
    /* assign default methods */
    parent_class->activate = priv_activate_gst;
    parent_class->deactivate = priv_deactivate_gst;
    parent_class->refresh = priv_refresh_gst;
    parent_class->static_capabilities = priv_static_capabilities_gst;
    
    /* property: audio input type */
    g_object_class_install_property(G_OBJECT_CLASS(klass),
                                    PROP_AUDIO_INPUT_TYPE,
                                    g_param_spec_string("audio-input-type", "Audio input type", "Audio input type (gst element name).", NULL, G_PARAM_READWRITE));
    
    /* property: audio input device */
    g_object_class_install_property(G_OBJECT_CLASS(klass),
                                    PROP_AUDIO_INPUT_DEVICE,
                                    g_param_spec_string("audio-input-device", "Audio input device", "Audio input device (gst element name).", NULL, G_PARAM_READWRITE));
    
    /* property: audio output type */
    g_object_class_install_property(G_OBJECT_CLASS(klass),
                                    PROP_AUDIO_OUTPUT_TYPE,
                                    g_param_spec_string("audio-output-type", "Audio output type", "Audio output type (gst element name).", NULL, G_PARAM_READWRITE));
    
    /* property: audio output device */
    g_object_class_install_property(G_OBJECT_CLASS(klass),
                                    PROP_AUDIO_OUTPUT_DEVICE,
                                    g_param_spec_string("audio-output-device", "Audio output device", "Audio output device (gst element name).", NULL, G_PARAM_READWRITE));
    
    /* property: STUN server */
    g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_STUN_SERVER,
                                     g_param_spec_string ("stun-server", "STUN server address",
                                                          "STUN server addresses; hostname or IP",
                                                          NULL, G_PARAM_READWRITE));
    
    /* property: STUN domain */
    g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_STUN_DOMAIN,
                                     g_param_spec_string ("stun-domain", "STUN domain address",
                                                          "domain for STUN DNS-SRV lookup",
                                                          NULL, G_PARAM_READWRITE));
    
}

static gboolean priv_verify_required_elements(void)
{
    static char *ssc_gst_elements[] = { "mulawenc", "mulawdec", "udpsink", "udpsrc", NULL };
    int i, failed = 0;
    
    g_debug("%s:%d", G_STRFUNC, __LINE__);
    
    /* check that all required gst elements are installed */
    for(i = 0; ssc_gst_elements[i] != NULL; i++) {
        GstElementFactory *f = gst_element_factory_find (ssc_gst_elements[i]);
        g_message("Verifying GST element \"%s\" -> %s",
                  ssc_gst_elements[i],
                  (f ? "OK" : "FAILED"));
        if (f)
            gst_object_unref(f);
        else
            ++failed;
    }
    
    if (failed) {
        g_warning("Some required gstreamer elements not found on the system, cannot initialize the GStreamer-RTP media subsystem!");
        return FALSE;
    }
    
    return TRUE;
}

static void ssc_media_gst_init (SscMediaGst *object)
{
    SscMediaGst *self = SSC_MEDIA_GST (object);
    const char * const ad_type_getenv = getenv("SOFSIP_AUDIO");
    const char *ad_type = SOFSIP_DEFAULT_AUDIO;
#if __APPLE_CC__
    /* ugly hack, but let's keep maintain the behaviour for OSX users */
    if (strcmp(ad_type, "ALSA") == 0) ad_type = "OSX";
#endif
    
    if (ad_type_getenv)
        ad_type = ad_type_getenv;
    
    self->sm_rtp_sockfd = -1;
    /* turn into properties */
    self->sm_ad_input_type = g_strdup(ad_type);
    self->sm_ad_output_type = g_strdup(ad_type);
    self->sm_ad_input_device = NULL;
    self->sm_ad_output_device = NULL;
}

static void ssc_media_gst_finalize (GObject *object)
{
    SscMediaGst *self = SSC_MEDIA_GST (object);
    
    g_debug(G_STRFUNC);
    g_assert(self);
}

static void ssc_media_gst_dispose (GObject *object)
{
    SscMediaGst *self = SSC_MEDIA_GST (object);
    
    if (!self->dispose_run) {
        self->dispose_run = TRUE;
        
        if (ssc_media_is_initialized(SSC_MEDIA(self)))
            priv_deactivate_gst(SSC_MEDIA(self));
        
        g_free(self->sm_ad_input_type);
        g_free(self->sm_ad_input_device);
        g_free(self->sm_ad_output_type);
        g_free(self->sm_ad_output_device);
        g_free(self->sm_stun_server);
        g_free(self->sm_stun_domain);
    }
}

static void
ssc_media_gst_set_property (GObject      *object,
                            guint         prop_id,
                            const GValue *value,
                            GParamSpec   *pspec)
{
    SscMediaGst *self;
    
    g_return_if_fail (SSC_IS_MEDIA_GST (object));
    self = SSC_MEDIA_GST (object);
    
    switch (prop_id) {
        case PROP_AUDIO_INPUT_TYPE:
            g_free(self->sm_ad_input_type);
            self->sm_ad_input_type = g_strdup(g_value_get_string (value));
            break;
        case PROP_AUDIO_INPUT_DEVICE:
            g_free(self->sm_ad_input_device);
            self->sm_ad_input_device = g_strdup(g_value_get_string (value));
            break;
        case PROP_AUDIO_OUTPUT_TYPE:
            g_free(self->sm_ad_output_type);
            self->sm_ad_output_type = g_strdup(g_value_get_string (value));
            break;
        case PROP_AUDIO_OUTPUT_DEVICE:
            g_free(self->sm_ad_output_device);
            self->sm_ad_output_device = g_strdup(g_value_get_string (value));
            break;
        case PROP_STUN_SERVER:
            g_free(self->sm_stun_server);
            self->sm_stun_server = g_strdup(g_value_get_string (value));
            break;
        case PROP_STUN_DOMAIN:
            g_free(self->sm_stun_domain);
            self->sm_stun_domain = g_strdup(g_value_get_string (value));
            break;
        default:
            g_debug("Unknown object property %s:%u.", G_OBJECT_TYPE_NAME(object), prop_id);
    }
}

static void
ssc_media_gst_get_property (GObject    *object,
                            guint       prop_id,
                            GValue     *value,
                            GParamSpec *pspec)
{
    SscMediaGst *self;
    
    g_return_if_fail (SSC_IS_MEDIA_GST (object));
    
    self = SSC_MEDIA_GST (object);
    
    switch (prop_id) {
        case PROP_AUDIO_INPUT_TYPE: g_value_set_string (value, self->sm_ad_input_type); break;
        case PROP_AUDIO_INPUT_DEVICE: g_value_set_string (value, self->sm_ad_input_type); break;
        case PROP_AUDIO_OUTPUT_TYPE: g_value_set_string (value, self->sm_ad_output_type); break;
        case PROP_AUDIO_OUTPUT_DEVICE: g_value_set_string (value, self->sm_ad_output_type); break;
        case PROP_STUN_SERVER: g_value_set_string(value, self->sm_stun_server); break;
        case PROP_STUN_DOMAIN: g_value_set_string(value, self->sm_stun_domain); break;
        default:
            g_debug("Unknown object property %s:%u.", G_OBJECT_TYPE_NAME(object), prop_id);
    }
}

static int priv_activate_gst(SscMedia *parent)
{
    SscMediaGst *self = SSC_MEDIA_GST (parent);
    int len = 0, res = 0;
    char *l_sdp_str = NULL;
    sdp_session_t *l_sdp = NULL;
    
    g_debug(G_STRFUNC);
    
    if (parent->sm_sdp_local == NULL) {
        ssc_media_set_local_to_caps(parent);
    }
    if (parent->sm_sdp_remote == NULL) {
        /* remote SDP not yet known, create a dummy one from
         * our own SDP */
        ssc_media_set_remote_to_local(parent);
    }
    
    /* get local port */
    l_sdp = sdp_session(parent->sm_sdp_local);
    if (l_sdp && l_sdp->sdp_media->m_port)
        self->sm_rtp_lport = l_sdp->sdp_media->m_port;
    
    g_debug(G_STRFUNC);
    
    // TODO: now that gsreamer is removed we can't have this check. Check if we need to add anything else
    //if (self->sm_depay == NULL) {
        // TODO: this isn't needed anymore, we 're using webrtc media
        //res = priv_setup_rtpelements(self);
        ssc_media_signal_state_change (parent, sm_active);
        //priv_cb_ready(NULL, self);
    //}
    
    return res;
}

static int priv_refresh_gst(SscMedia *parent)
{
    SscMediaGst *self = SSC_MEDIA_GST (parent);
    int res = 0;
    
    /* XXX: no RX hot updates supported yet */
    priv_update_tx_elements(self);
    
    return res;
}

static int priv_deactivate_gst(SscMedia *parent)
{
    SscMediaGst *self = SSC_MEDIA_GST (parent);
    
    g_assert(ssc_media_is_initialized(parent) == TRUE);
    
    g_debug(G_STRFUNC);
    
    /*
    if (self->sm_pipeline) {
        gst_element_set_state (self->sm_pipeline, GST_STATE_PAUSED);
        gst_element_set_state (self->sm_pipeline, GST_STATE_NULL);
    }
    */
    
    parent->sm_state = sm_disabled;
    
    /*
    if (self->sm_netsocket)
        g_object_unref(G_OBJECT (self->sm_netsocket)), self->sm_netsocket = NULL;
     */
    
    if (self->sm_rtp_sockfd != -1)
        close(self->sm_rtp_sockfd), self->sm_rtp_sockfd = -1;
    if (self->sm_rtcp_sockfd != -1)
        close(self->sm_rtcp_sockfd), self->sm_rtp_sockfd = self->sm_rtcp_sockfd = -1;
    
    /*
    if (self->sm_pipeline) {
        // XXX: gets stuck on gst-0.10.2, must fix, we are leaking memory otherwise
        gst_object_unref(GST_OBJECT (self->sm_pipeline));
        
        self->sm_pipeline = NULL;
        self->sm_depay = NULL;
    }
    */
    
    self->sm_rx_elements = 0;
    self->sm_tx_elements = 0;
    
    g_assert(ssc_media_is_initialized(parent) != TRUE);
    
    // TODO: need to fix this; normally this return is not needed but for some reason XCode fails to understand that g_assert is a macro that return a value
    return 0;
}

static int priv_static_capabilities_gst(SscMedia *parent, char **dest)
{
    SscMediaGst *self = SSC_MEDIA_GST (parent);
    su_home_t *home = parent->sm_home;
    char *caps_sdp_str = NULL;
    GstCaps *pt_caps;
    g_debug(G_STRFUNC);
    
    self->sm_pt = 0; /* PT=0 => PCMU */
    
    /* step: initialize the PT<->caps hash table */
    
    pt_caps = gst_caps_new_simple ("application/x-rtp",
                                   "clock-rate", G_TYPE_INT, 8000,
                                   "encoding-name", G_TYPE_STRING, "PCMU",
                                   NULL);
    
    /* step: describe capabilities in SDP terms */
    
    /* support only G711/PCMU */
    caps_sdp_str = su_strcat(home, caps_sdp_str,
                             "v=0\r\n"
                             "m=audio 0 RTP/AVP 0\r\n"
                             "a=rtpmap:0 PCMU/8000\r\n");
    
    *dest = strdup(caps_sdp_str);
    su_free(home, caps_sdp_str);
    
    return 0;
}

/*
static int priv_setup_rtpelements(SscMediaGst *self)
{
    GType netsocket_type = FARSIGHT_NETSOCKET_TYPE;
    FarsightNetsocket *netsocket = NULL;
    gboolean cb_sched = FALSE;
    int pri_sockfd, aux_sockfd = -1;
    guint16 l_port = SSC_MEDIA_RTP_PORT_RANGE_START;
    
    g_debug(G_STRFUNC);
    
    if (self->sm_rtp_lport != 0)
        l_port = self->sm_rtp_lport;
    
    g_assert(self->sm_depay == NULL);
    
    pri_sockfd =
    farsight_netsocket_bind_udp_port(AF_INET,
                                     NULL,
                                     &l_port,
                                     TRUE,
                                     NULL
                                     );
    
    if (pri_sockfd >= 0) {
        self->sm_rtp_sockfd = pri_sockfd;
        self->sm_rtcp_sockfd = aux_sockfd;
        self->sm_rtp_lport = l_port;
        
        if (self->sm_stun_server || self->sm_stun_domain) {
            self->sm_netsocket = NULL;
            netsocket_type = FARSIGHT_NETSOCKET_STUN_TYPE;
            netsocket = g_object_new (netsocket_type,
                                      "sockfd", pri_sockfd,
                                      "aux-sockfd", aux_sockfd,
                                      "server", self->sm_stun_server,
                                      "domain", self->sm_stun_domain,
                                      NULL);
            if (netsocket) {
                g_signal_connect (G_OBJECT (netsocket), "ready",
                                  G_CALLBACK (priv_cb_ready), self);
                self->sm_netsocket = netsocket;
                
                cb_sched = farsight_netsocket_map(netsocket);
                
                if (cb_sched != TRUE) {
                    g_warning("Problems in initiating connection to STUN server.");
                    g_object_unref(G_OBJECT (self->sm_netsocket)), self->sm_netsocket = NULL;
                }
            }
        }
        
        if (cb_sched != TRUE) {
            priv_cb_ready(NULL, self);
        }
    }
    else {
        g_error("%s: unable to bind to local sockets.\n", G_STRFUNC);
    }
    
    return (pri_sockfd >= 0 ? 0 : -1);
}
 */

/*
static void priv_cb_ready(FarsightNetsocket *netsocket, gpointer data)
{
    SscMediaGst *self = SSC_MEDIA_GST(data);
    SscMedia *parent = SSC_MEDIA (self);
    GError *error = NULL;
    
    //GST_DEBUG ("Creating pipeline");
    
    gst_debug_set_threshold_from_string("2,*audio*:3", TRUE);
    //pipeline = gst_parse_launch("audiotestsrc ! audioconvert ! audioresample ! autoaudiosink", &error);
    // From mic to loudspeaker
    //self->sm_pipeline = gst_parse_launch("autoaudiosrc ! audioconvert ! audioresample ! autoaudiosink", &error);
    // Only TX (no errors) - fixed voice 'breaking' issue
    //self->sm_pipeline = gst_parse_launch("autoaudiosrc ! capsfilter caps=audio/x-raw,rate=44100 ! audioconvert ! audioresample ! mulawenc ! rtppcmupay ! udpsink name=udp-sink", &error);
    // Only TX with jitter buffer (rtpbin) (no errors)
    //self->sm_pipeline = gst_parse_launch("rtpbin name=rtpbin autoaudiosrc ! audioconvert ! audioresample ! mulawenc ! rtppcmupay ! rtpbin.send_rtp_sink_0 rtpbin.send_rtp_src_0 ! udpsink name=udp-sink", &error);
    // Only RX (no errors)
    //self->sm_pipeline = gst_parse_launch("udpsrc name=udp-src caps=\"application/x-rtp,clock-rate=8000,encoding-name=PCMU\" ! rtppcmudepay ! mulawdec ! audioconvert ! audioresample ! autoaudiosink", &error);
    // Only RX with jitter buffer (works with 'cannot get clock-rate for pt 0)
    //self->sm_pipeline = gst_parse_launch("rtpbin name=rtpbin udpsrc name=udp-src caps=\"application/x-rtp,media=audio,clock-rate=8000,encoding-name=PCMU\" ! rtpbin.recv_rtp_sink_0 rtpbin. ! rtppcmudepay ! mulawdec ! audioconvert ! audioresample ! autoaudiosink", &error);
    // Bydirectional
    self->sm_pipeline = gst_parse_launch("autoaudiosrc ! capsfilter caps=audio/x-raw,rate=44100 ! audioconvert ! audioresample ! queue ! mulawenc ! rtppcmupay ! udpsink name=udp-sink udpsrc name=udp-src caps=\"application/x-rtp,media=audio,clock-rate=8000,encoding-name=PCMU\" ! rtppcmudepay ! mulawdec ! audioconvert ! audioresample ! autoaudiosink", &error);
    // Bydirectional with jitter buffer (not working yet)
    
    if (error) {
        gchar *message = g_strdup_printf("Unable to build pipeline: %s", error->message);
        g_clear_error (&error);
        // TODO:
        //[self setUIMessage:message];
        g_free (message);
        return;
    }
    
    // convert socket to gsocket
    GError *err = NULL;
    GSocket * gsocket = g_socket_new_from_fd(self->sm_rtp_sockfd, &err);
    if (err != NULL) {
        // Report error to user, and free error
        fprintf (stderr, "error getting gsocket: %s\n", err->message);
        g_error_free (err);
    }
    self->sm_udpsink = gst_bin_get_by_name (GST_BIN(self->sm_pipeline), "udp-sink");
    g_object_set (G_OBJECT (self->sm_udpsink),
                  "async", FALSE,
                  //"socket", gsocket,
                  NULL);
    // convert socket to gsocket
    self->sm_udpsrc = gst_bin_get_by_name (GST_BIN(self->sm_pipeline), "udp-src");
    g_object_set (G_OBJECT (self->sm_udpsrc),
                  //"port", self->sm_rtp_lport,
                  "socket", gsocket,
                  NULL);
    
    // note: emit "state-changed" signal from base class
    ssc_media_signal_state_change (parent, sm_active);
    
    return;
}
 */

static gboolean priv_cb_pipeline_bus (GstBus *bus, GstMessage *message, gpointer data)
{
    SscMediaGst *self = SSC_MEDIA_GST(data);
    
    switch (GST_MESSAGE_TYPE (message)) {
        case GST_MESSAGE_ERROR: {
            GError *err;
            gchar *debug;
            
            gst_message_parse_error (message, &err, &debug);
            g_print ("%s: Error: %s\n", G_STRFUNC, err->message);
            g_error_free (err);
            g_free (debug);
            
            /* XXX: we don't have pointer to the main loop, so let's just
             *      quit the whole thing on error */
            exit(0);
            break;
        }
        case GST_MESSAGE_NEW_CLOCK:
        case GST_MESSAGE_CLOCK_PROVIDE:
            /* normal clock handling events */
            break;
            
        case GST_MESSAGE_STATE_CHANGED:
            /* state changed */
            g_print ("%s: State changed\n", G_STRFUNC);
            break;
            
        case GST_MESSAGE_STREAM_STATUS: {
            // stream status changed
            g_print ("%s: Stream status changed\n", G_STRFUNC);
            break;
        }
        case GST_MESSAGE_TAG:
            g_print ("%s: Tag found\n", G_STRFUNC);
            break;
            
        default:
            /* unhandled message */
            g_print ("%s: Unhandled bus message from element %s (%s).\n", 
                     G_STRFUNC, gst_object_get_name(message->src),
                     gst_message_type_get_name(GST_MESSAGE_TYPE(message)));
            break;
    }
    
    self = NULL;
    
    /* remove message from the queue */
    return TRUE;
}

/**
 * Updates configuration of RX elements of
 * an already activated session.
 */
/*
static int priv_update_rx_elements(SscMediaGst *self)
{
    SscMedia *parent = SSC_MEDIA (self);
    sdp_session_t *l_sdp;
    int result = 0;
    
    g_debug(G_STRFUNC);
    
    if (parent->sm_sdp_local) 
        l_sdp = sdp_session(parent->sm_sdp_local);
    
    // step: update the port number in local SDP
    if (l_sdp) {
        
        if (self->sm_netsocket) {
            guint c_port = 0;
            gchar *c_addr = NULL;
            g_object_get (G_OBJECT(self->sm_netsocket), 
                          "contactport", &c_port,
                          "contactaddr", &c_addr,
                          NULL);
            
            if (c_addr && c_port) {
                l_sdp->sdp_media->m_port = c_port;
                
                g_debug("%s: using contact address %s:%u", G_STRFUNC, c_addr, (unsigned int)c_port);
                
                result = sdp_set_contact(parent->sm_sdp_local, l_sdp->sdp_media, sdp_net_in, sdp_addr_ip4, c_addr);
            }
            else {
                g_debug("%s: not modifying local contact address", G_STRFUNC);
            }
            
            g_free(c_addr);
        }
        
        if (l_sdp->sdp_media->m_port == 0) {
            // local media active but SDP port zero, update
            l_sdp->sdp_media->m_port = self->sm_rtp_lport;
        }
        
        // make sure the local ascii-SDP is regenerated
        if (parent->sm_sdp_local_str) 
            g_free(parent->sm_sdp_local_str), parent->sm_sdp_local_str = NULL;
    }
    
    return result;
}
 */

/**
 * Updates configuration of TX elements of
 * an already activaded session.
 */
static int priv_update_tx_elements(SscMediaGst *self)
{
    SscMedia *parent = SSC_MEDIA (self);
    sdp_session_t *r_sdp = sdp_session(parent->sm_sdp_remote);
    sdp_connection_t *r_c = (!r_sdp) ? NULL : sdp_media_connections(r_sdp->sdp_media);
    
    g_debug(G_STRFUNC);
    
    if (r_c && r_sdp) {
        //g_return_val_if_fail(self->sm_udpsink != NULL, -1);
        g_message("RTP destination is: %s:%lu.", r_c->c_address, r_sdp->sdp_media->m_port);
        /*
        g_object_set(G_OBJECT(self->sm_udpsink), 
                     "host", r_c->c_address, 
                     "port", r_sdp->sdp_media->m_port,
                     NULL);
         */
    }
    else 
        g_message("No RTP destination available (r_sdp=%p).", (void*)r_sdp);
    
    return 0;
}

#endif /* HAVE_GST */
